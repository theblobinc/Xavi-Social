#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TARGET_ROOT="$ROOT_DIR"
TZ_PACIFIC="America/Los_Angeles"

STAMP_HUMAN="$(TZ="$TZ_PACIFIC" date '+%Y-%m-%d %I:%M:%S %p %Z')"
STAMP_FILE="$(TZ="$TZ_PACIFIC" date '+%Y-%m-%d_%I-%M-%S_%p_%Z')"

OUT_DIR="$ROOT_DIR/_private/dumps"
mkdir -p "$OUT_DIR"

OUT_FILE="$OUT_DIR/ai-dump-light_${STAMP_FILE}.txt"
LATEST_FILE="$OUT_DIR/ai-dump-light_latest.txt"

collect_files_raw() {
  local root="$1"

  if command -v git >/dev/null 2>&1 && git -C "$root" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    git -C "$root" ls-files -z --cached --others --exclude-standard
    return
  fi

  (cd "$root" && find . \
    \( -type d \( -name 'dist' -o -name '_private' -o -name '.git' -o -name 'node_modules' -o -name 'vendor' -o -name 'data' -o -path './docker/data' \) -prune \) -o \
    -type f -print0
  )
}

collect_files_light() {
  local root="$1"

  local py
    py=$'import os\nimport sys\n\nEXCLUDE_DIRS = {"dist", "_private", ".git", "node_modules", "vendor", "data"}\nALLOW_PREFIXES = [\n    "controller.php",\n    "controllers/",\n    "single_pages/",\n    "src/",\n    "multigrid/",\n    "frontend/src/",\n    "frontend/index.html",\n    "frontend/package.json",\n    "frontend/package-lock.json",\n    "frontend/vite.config.js",\n    "docker/compose/",\n    "docker/scripts/",\n    "db.xml",\n    "AI-DUMP.sh",\n    "ai-dump-light.sh",\n    "TODO.md",\n]\n\nALLOW_EXTS = {\n    ".php", ".js", ".ts", ".jsx", ".tsx",\n    ".css", ".scss", ".sass", ".less",\n    ".json", ".yml", ".yaml",\n    ".html", ".htm",\n}\n\nALWAYS_ALLOW = {"TODO.md"}\n\nraw = sys.stdin.buffer.read().split(b"\\0")\nout = []\n\nfor p in raw:\n    if not p:\n        continue\n    s = p.decode("utf-8", errors="replace")\n    s = s[2:] if s.startswith("./") else s\n    if not s:\n        continue\n    parts = [x for x in s.split("/") if x]\n    if any(x in EXCLUDE_DIRS for x in parts):\n        continue\n\n    base = os.path.basename(s)\n    base_lower = base.lower()\n    ext = os.path.splitext(base_lower)[1]\n\n    if base in ALWAYS_ALLOW:\n        out.append(s)\n        continue\n\n    for pref in ALLOW_PREFIXES:\n        if s == pref or s.startswith(pref):\n            if ext in ALLOW_EXTS or not ext:\n                out.append(s)\n            break\n\nout.sort()\nfor s in out:\n    sys.stdout.buffer.write(s.encode("utf-8", errors="replace") + b"\\0")\n'

  collect_files_raw "$root" | python3 -c "$py"
}

render_tree() {
  python3 -c $'import sys\n\ndata = sys.stdin.buffer.read().split(b"\\0")\npaths = [p.decode("utf-8", errors="replace") for p in data if p]\npaths = [p[2:] if p.startswith("./") else p for p in paths]\npaths = [p for p in paths if p]\npaths.sort()\n\ntree = {}\nfor p in paths:\n    cur = tree\n    parts = p.split("/")\n    for part in parts:\n        cur = cur.setdefault(part, {})\n\ndef walk(node, prefix=""):\n    keys = sorted(node.keys())\n    for idx, key in enumerate(keys):\n        last = idx == len(keys) - 1\n        branch = "└── " if last else "├── "\n        print(prefix + branch + key)\n        child = node[key]\n        if child:\n            ext = "    " if last else "│   "\n            walk(child, prefix + ext)\n\nprint(".")\nwalk(tree)\n'
}

{
  echo "AI DUMP (LIGHT)"
  echo "Timestamp: $STAMP_HUMAN"
  echo "Root: $TARGET_ROOT"
  echo "Generated by: $ROOT_DIR/ai-dump-light.sh"
  echo

  echo "==== FILE TREE (light) ===="
  collect_files_light "$TARGET_ROOT" | render_tree || true
  echo

  echo "==== FILE CONTENTS (light) ===="
  while IFS= read -r -d '' rel; do
    [[ -z "$rel" ]] && continue
    rel="${rel#./}"
    abs="$TARGET_ROOT/$rel"

    [[ -f "$abs" ]] || continue

    size=$(stat -c %s "$abs" 2>/dev/null || echo 0)
    if [[ "$size" -gt $((2 * 1024 * 1024)) ]]; then
      echo "----- FILE: $rel (skipped: ${size} bytes) -----"
      echo
      continue
    fi

    if ! grep -Iq . "$abs"; then
      echo "----- FILE: $rel (skipped: binary) -----"
      echo
      continue
    fi

    echo "----- FILE: $rel -----"
    echo "PATH: $abs"
    echo
    cat "$abs"
    echo
  done < <(collect_files_light "$TARGET_ROOT")
} >"$OUT_FILE"

cp -f "$OUT_FILE" "$LATEST_FILE"

echo "Wrote: $OUT_FILE"
echo "Latest: $LATEST_FILE"
